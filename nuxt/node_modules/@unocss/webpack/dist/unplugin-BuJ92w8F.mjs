import { isAbsolute, normalize, resolve } from "node:path";
import process from "node:process";
import fs from "node:fs/promises";
import { glob } from "tinyglobby";
import remapping from "@jridgewell/remapping";
import MagicString from "magic-string";
import { BetterMap, createGenerator, cssIdRE } from "@unocss/core";
import { createRecoveryConfigLoader } from "@unocss/config";
import { createFilter } from "unplugin-utils";
import crypto from "node:crypto";
import { resolve as resolve$1 } from "pathe";
import { createUnplugin } from "unplugin";
import WebpackSources from "webpack-sources";

//#region ../../virtual-shared/integration/src/constants.ts
const INCLUDE_COMMENT = "@unocss-include";
const IGNORE_COMMENT = "@unocss-ignore";
const CSS_PLACEHOLDER = "@unocss-placeholder";
const SKIP_START_COMMENT = "@unocss-skip-start";
const SKIP_END_COMMENT = "@unocss-skip-end";
const SKIP_COMMENT_RE = new RegExp(`(\/\/\\s*?${SKIP_START_COMMENT}\\s*?|\\/\\*\\s*?${SKIP_START_COMMENT}\\s*?\\*\\/|<!--\\s*?${SKIP_START_COMMENT}\\s*?-->)[\\s\\S]*?(\/\/\\s*?${SKIP_END_COMMENT}\\s*?|\\/\\*\\s*?${SKIP_END_COMMENT}\\s*?\\*\\/|<!--\\s*?${SKIP_END_COMMENT}\\s*?-->)`, "g");
const VIRTUAL_ENTRY_ALIAS = [/^(?:virtual:)?uno(?::(.+))?\.css(\?.*)?$/];
const LAYER_MARK_ALL = "__ALL__";

//#endregion
//#region ../../virtual-shared/integration/src/utils.ts
function getPath(id) {
	return id.replace(/\?.*$/, "");
}
function isCssId(id) {
	return cssIdRE.test(id);
}
function hash$1(str) {
	let i;
	let l;
	let hval = 2166136261;
	for (i = 0, l = str.length; i < l; i++) {
		hval ^= str.charCodeAt(i);
		hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
	}
	return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}
function transformSkipCode(code, map, SKIP_RULES_RE, keyFlag) {
	for (const item of Array.from(code.matchAll(SKIP_RULES_RE))) if (item != null) {
		const matched = item[0];
		const withHashKey = `${keyFlag}${hash$1(matched)}`;
		map.set(withHashKey, matched);
		code = code.replace(matched, withHashKey);
	}
	return code;
}
function restoreSkipCode(code, map) {
	for (const [withHashKey, matched] of map.entries()) code = code.replaceAll(withHashKey, matched);
	return code;
}

//#endregion
//#region ../../virtual-shared/integration/src/transformers.ts
async function applyTransformers(ctx, original, id, enforce = "default") {
	if (original.includes(IGNORE_COMMENT)) return;
	const transformers = (ctx.uno.config.transformers || []).filter((i) => (i.enforce || "default") === enforce);
	if (!transformers.length) return;
	const skipMap = /* @__PURE__ */ new Map();
	let code = original;
	let s = new MagicString(transformSkipCode(code, skipMap, SKIP_COMMENT_RE, "@unocss-skip-placeholder-"));
	const maps = [];
	for (const t of transformers) {
		if (t.idFilter) {
			if (!t.idFilter(id)) continue;
		} else if (!ctx.filter(code, id)) continue;
		await t.transform(s, id, ctx);
		if (s.hasChanged()) {
			code = restoreSkipCode(s.toString(), skipMap);
			maps.push(s.generateMap({
				hires: true,
				source: id
			}));
			s = new MagicString(code);
		}
	}
	if (code !== original) return {
		code,
		map: remapping(maps, (_, ctx$1) => {
			ctx$1.content = code;
			return null;
		})
	};
}

//#endregion
//#region ../../virtual-shared/integration/src/content.ts
async function setupContentExtractor(ctx, shouldWatch = false) {
	const { content } = await ctx.getConfig();
	const { extract, tasks, root, filter } = ctx;
	if (content?.inline) await Promise.all(content.inline.map(async (c, idx) => {
		if (typeof c === "function") c = await c();
		if (typeof c === "string") c = { code: c };
		return extract(c.code, c.id ?? `__plain_content_${idx}__`);
	}));
	if (content?.filesystem) {
		const files = await glob(content.filesystem, {
			cwd: root,
			expandDirectories: false
		});
		async function extractFile(file) {
			file = isAbsolute(file) ? file : resolve(root, file);
			const code = await fs.readFile(file, "utf-8");
			if (!filter(code, file)) return;
			const preTransform = await applyTransformers(ctx, code, file, "pre");
			await applyTransformers(ctx, (await applyTransformers(ctx, preTransform?.code || code, file))?.code || preTransform?.code || code, file, "post");
			return await extract(preTransform?.code || code, file);
		}
		if (shouldWatch) {
			const { watch } = await import("chokidar");
			watch(files, {
				ignorePermissionErrors: true,
				ignored: ["**/{.git,node_modules}/**"],
				cwd: root,
				ignoreInitial: true
			}).on("all", (type, file) => {
				if (type === "add" || type === "change") {
					const absolutePath = resolve(root, file);
					tasks.push(extractFile(absolutePath));
				}
			});
		}
		await Promise.all(files.map(extractFile));
	}
}

//#endregion
//#region ../../virtual-shared/integration/src/defaults.ts
const defaultPipelineExclude = [cssIdRE];
const defaultPipelineInclude = [/\.(vue|svelte|[jt]sx|vine.ts|mdx?|astro|elm|php|phtml|marko|html)($|\?)/];

//#endregion
//#region ../../virtual-shared/integration/src/deprecation.ts
function deprecationCheck(config) {}

//#endregion
//#region ../../virtual-shared/integration/src/context.ts
function createContext(configOrPath, defaults = {}, extraConfigSources = [], resolveConfigResult = () => {}) {
	let root = process.cwd();
	let rawConfig = {};
	let configFileList = [];
	let uno;
	const _uno = createGenerator(rawConfig, defaults).then((r) => {
		uno = r;
		return r;
	});
	let rollupFilter = createFilter(defaultPipelineInclude, defaultPipelineExclude, { resolve: typeof configOrPath === "string" ? configOrPath : root });
	const invalidations = [];
	const reloadListeners = [];
	const modules = new BetterMap();
	const tokens = /* @__PURE__ */ new Set();
	const tasks = [];
	const affectedModules = /* @__PURE__ */ new Set();
	const loadConfig = createRecoveryConfigLoader();
	let ready = reloadConfig();
	async function reloadConfig() {
		await _uno;
		const result = await loadConfig(root, configOrPath, extraConfigSources, defaults);
		resolveConfigResult(result);
		/* @__PURE__ */ deprecationCheck(result.config);
		rawConfig = result.config;
		configFileList = result.sources;
		await uno.setConfig(rawConfig);
		uno.config.envMode = "dev";
		rollupFilter = rawConfig.content?.pipeline === false ? () => false : createFilter(rawConfig.content?.pipeline?.include || defaultPipelineInclude, rawConfig.content?.pipeline?.exclude || defaultPipelineExclude, { resolve: typeof configOrPath === "string" ? configOrPath : root });
		tokens.clear();
		await Promise.all(modules.map((code, id) => uno.applyExtractors(code.replace(SKIP_COMMENT_RE, ""), id, tokens)));
		invalidate();
		dispatchReload();
		return result;
	}
	async function updateRoot(newRoot) {
		if (newRoot !== root) {
			root = newRoot;
			ready = reloadConfig();
		}
		return await ready;
	}
	function invalidate() {
		invalidations.forEach((cb) => cb());
	}
	function dispatchReload() {
		reloadListeners.forEach((cb) => cb());
	}
	async function extract(code, id) {
		const uno$1 = await _uno;
		if (id) modules.set(id, code);
		const len = tokens.size;
		await uno$1.applyExtractors(code.replace(SKIP_COMMENT_RE, ""), id, tokens);
		if (tokens.size > len) invalidate();
	}
	function filter(code, id) {
		if (code.includes(IGNORE_COMMENT)) return false;
		return code.includes(INCLUDE_COMMENT) || code.includes(CSS_PLACEHOLDER) || rollupFilter(id.replace(/\?v=\w+$/, ""));
	}
	async function getConfig() {
		await ready;
		return rawConfig;
	}
	async function flushTasks() {
		const _tasks = [...tasks];
		await Promise.all(_tasks);
		if (tasks[0] === _tasks[0]) tasks.splice(0, _tasks.length);
	}
	/**
	* Get regexes to match virtual module ids
	*/
	const vmpCache = /* @__PURE__ */ new Map();
	async function getVMPRegexes() {
		const prefix = (await getConfig()).virtualModulePrefix || "__uno";
		if (vmpCache.has(prefix)) return vmpCache.get(prefix);
		const regexes = {
			prefix,
			RESOLVED_ID_WITH_QUERY_RE: /* @__PURE__ */ new RegExp(`[/\\\\]${prefix}(_.*?)?\\.css(\\?.*)?$`),
			RESOLVED_ID_RE: /* @__PURE__ */ new RegExp(`[/\\\\]${prefix}(?:_(.*?))?\.css$`)
		};
		vmpCache.set(prefix, regexes);
		return regexes;
	}
	return {
		get ready() {
			return ready;
		},
		tokens,
		modules,
		affectedModules,
		tasks,
		flushTasks,
		invalidate,
		onInvalidate(fn) {
			invalidations.push(fn);
		},
		filter,
		reloadConfig,
		onReload(fn) {
			reloadListeners.push(fn);
		},
		get uno() {
			if (!uno) throw new Error("Run `await context.ready` before accessing `context.uno`");
			return uno;
		},
		extract,
		getConfig,
		get root() {
			return root;
		},
		updateRoot,
		getConfigFileList: () => configFileList,
		getVMPRegexes
	};
}

//#endregion
//#region ../../virtual-shared/integration/src/hash.ts
const hash = crypto.hash ?? ((algorithm, data, outputEncoding) => crypto.createHash(algorithm).update(data).digest(outputEncoding));
function getHash(input, length = 8) {
	return hash("sha256", input, "hex").substring(0, length);
}

//#endregion
//#region ../../virtual-shared/integration/src/layers.ts
async function resolveId(ctx, id, importer) {
	const { RESOLVED_ID_WITH_QUERY_RE, prefix } = await ctx.getVMPRegexes();
	if (id.match(RESOLVED_ID_WITH_QUERY_RE)) return id;
	for (const alias of VIRTUAL_ENTRY_ALIAS) {
		const match = id.match(alias);
		if (match) {
			let virtual = match[1] ? `${prefix}_${match[1]}.css` : `${prefix}.css`;
			virtual += match[2] || "";
			if (importer) virtual = resolve$1(importer, "..", virtual);
			else virtual = `/${virtual}`;
			return virtual;
		}
	}
}
async function resolveLayer(ctx, id) {
	const { RESOLVED_ID_RE } = await ctx.getVMPRegexes();
	const match = id.match(RESOLVED_ID_RE);
	if (match) return match[1] || LAYER_MARK_ALL;
}
/**
* 1 - layer
* 2 - escape-view
*                                                                   111                             222
*/
const LAYER_PLACEHOLDER_RE = /#--unocss--\s*\{\s*layer\s*:\s*(.+?)\s*(?:;\s*escape-view\s*:\s*(.+?)\s*)?;?\s*\}/g;
function getLayerPlaceholder(layer) {
	return `#--unocss--{layer:${layer};escape-view:\\"\\'\\\`\\\\}`;
}
function getCssEscaperForJsContent(view) {
	if (!view) return (css) => css;
	const prefix = {};
	view.trim().replace(/(\\*)\\(["'`\\])/g, (_, bs, char) => {
		prefix[char] = bs.replace(/\\\\/g, "\\");
		return "";
	});
	return (css) => css.replace(/["'`\\]/g, (v) => {
		return (prefix[v] || "") + v;
	});
}
const HASH_PLACEHOLDER_RE = /#--unocss-hash--\s*\{\s*content\s*:\s*\\*"([^\\"]+)\\*";?\s*\}/g;
function getHashPlaceholder(hash$2) {
	return `#--unocss-hash--{content:"${hash$2}"}`;
}

//#endregion
//#region src/unplugin.ts
const PLUGIN_NAME = "unocss:webpack";
const UPDATE_DEBOUNCE = 10;
function unplugin(configOrPath, defaults) {
	return createUnplugin(() => {
		const ctx = createContext(configOrPath, {
			envMode: process.env.NODE_ENV === "development" ? "dev" : "build",
			...defaults
		});
		const { tokens, filter, extract, onInvalidate, tasks, flushTasks } = ctx;
		let timer;
		onInvalidate(() => {
			clearTimeout(timer);
			timer = setTimeout(updateModules, UPDATE_DEBOUNCE);
		});
		tasks.push(setupContentExtractor(ctx, typeof configOrPath === "object" && configOrPath?.watch));
		const entries = /* @__PURE__ */ new Set();
		const hashes = /* @__PURE__ */ new Map();
		const plugin = {
			name: "unocss:webpack",
			enforce: "pre",
			async transform(code, id) {
				const { RESOLVED_ID_RE } = await ctx.getVMPRegexes();
				if (RESOLVED_ID_RE.test(id) || !filter("", id) || id.endsWith(".html")) return;
				const result = await applyTransformers(ctx, code, id, "pre");
				if (isCssId(id)) return result;
				if (result == null) tasks.push(extract(code, id));
				else tasks.push(extract(result.code, id));
				return result;
			},
			async resolveId(id) {
				const entry = await resolveId(ctx, id);
				if (entry === id) return;
				if (entry) {
					let query = "";
					const queryIndex = id.indexOf("?");
					if (queryIndex >= 0) query = id.slice(queryIndex);
					entries.add(entry);
					return entry + query;
				}
			},
			async load(id) {
				const layer = await getLayer(ctx, id);
				if (!layer) return;
				const hash$2 = hashes.get(id);
				return (hash$2 ? getHashPlaceholder(hash$2) : "") + getLayerPlaceholder(layer);
			},
			webpack(compiler) {
				compiler.hooks.beforeCompile.tapPromise(PLUGIN_NAME, async () => {
					await ctx.ready;
					const nonPreTransformers = ctx.uno.config.transformers?.filter((i) => i.enforce !== "pre");
					if (nonPreTransformers?.length) console.warn("[unocss] webpack integration only supports \"pre\" enforce transformers currently.the following transformers will be ignored\n" + nonPreTransformers.map((i) => ` - ${i.name}`).join("\n"));
				});
				compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {
					(compilation.hooks.processAssets || compilation.hooks.optimizeAssets).tapPromise(PLUGIN_NAME, async () => {
						await ctx.ready;
						const files = Object.keys(compilation.assets);
						await flushTasks();
						const result = await ctx.uno.generate(tokens, { minify: true });
						const resolvedLayers = (await Promise.all(Array.from(entries).map((i) => resolveLayer(ctx, i)))).filter((i) => !!i);
						for (const file of files) {
							if (file === "*") return;
							let code = compilation.assets[file].source().toString();
							let escapeCss;
							let replaced = false;
							code = code.replace(HASH_PLACEHOLDER_RE, "");
							code = code.replace(LAYER_PLACEHOLDER_RE, (_, layer, escapeView) => {
								replaced = true;
								const css = layer.trim() === LAYER_MARK_ALL ? result.getLayers(void 0, resolvedLayers) : result.getLayer(layer) || "";
								escapeCss = escapeCss ?? getCssEscaperForJsContent(escapeView.trim());
								return escapeCss(css);
							});
							if (replaced) compilation.assets[file] = new WebpackSources.SourceMapSource(code, file, compilation.assets[file].map());
						}
					});
				});
			},
			get rspack() {
				return this.webpack;
			}
		};
		let lastTokenSize = tokens.size;
		async function updateModules() {
			if (!plugin.__vfsModules) return;
			await flushTasks();
			const result = await ctx.uno.generate(tokens);
			if (lastTokenSize === tokens.size) return;
			lastTokenSize = tokens.size;
			let virtualModules;
			if (plugin.__vfsModules instanceof Map) virtualModules = Array.from(plugin.__vfsModules.keys());
			else virtualModules = Array.from(plugin.__vfsModules);
			const resolvedLayers = (await Promise.all(Array.from(entries).map((i) => resolveLayer(ctx, i)))).filter((i) => !!i);
			for (const id of virtualModules) {
				let path = decodeURIComponent(id.startsWith(plugin.__virtualModulePrefix) ? id.slice(plugin.__virtualModulePrefix.length) : id);
				path = normalizeAbsolutePath(path);
				const layer = await resolveLayer(ctx, path);
				if (!layer) continue;
				const code = layer === LAYER_MARK_ALL ? result.getLayers(void 0, resolvedLayers) : result.getLayer(layer) || "";
				const hash$2 = getHash(code);
				hashes.set(path, hash$2);
				plugin.__vfs.writeModule(id, code);
			}
		}
		return plugin;
	});
}
async function getLayer(ctx, id) {
	let layer = await resolveLayer(ctx, getPath(id));
	if (!layer) {
		const entry = await resolveId(ctx, id);
		if (entry) layer = await resolveLayer(ctx, entry);
	}
	return layer;
}
function normalizeAbsolutePath(path) {
	if (isAbsolute(path)) return normalize(path);
	else return path;
}

//#endregion
export { unplugin as t };